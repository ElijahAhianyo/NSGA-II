# Key Objects

[_Documentation generated by Documatic_](https://www.documatic.com)

<!---Documatic-section-NSGA II.fast_non_dominated_sort-start--->
## NSGA II.fast_non_dominated_sort

<!---Documatic-section-fast_non_dominated_sort-start--->
<!---Documatic-block-NSGA II.fast_non_dominated_sort-start--->
<details>
	<summary><code>NSGA II.fast_non_dominated_sort</code> code snippet</summary>

```python
def fast_non_dominated_sort(values1, values2):
    S = [[] for i in range(0, len(values1))]
    front = [[]]
    n = [0 for i in range(0, len(values1))]
    rank = [0 for i in range(0, len(values1))]
    for p in range(0, len(values1)):
        S[p] = []
        n[p] = 0
        for q in range(0, len(values1)):
            if values1[p] > values1[q] and values2[p] > values2[q] or (values1[p] >= values1[q] and values2[p] > values2[q]) or (values1[p] > values1[q] and values2[p] >= values2[q]):
                if q not in S[p]:
                    S[p].append(q)
            elif values1[q] > values1[p] and values2[q] > values2[p] or (values1[q] >= values1[p] and values2[q] > values2[p]) or (values1[q] > values1[p] and values2[q] >= values2[p]):
                n[p] = n[p] + 1
        if n[p] == 0:
            rank[p] = 0
            if p not in front[0]:
                front[0].append(p)
    i = 0
    while front[i] != []:
        Q = []
        for p in front[i]:
            for q in S[p]:
                n[q] = n[q] - 1
                if n[q] == 0:
                    rank[q] = i + 1
                    if q not in Q:
                        Q.append(q)
        i = i + 1
        front.append(Q)
    del front[len(front) - 1]
    return front
```
</details>
<!---Documatic-block-NSGA II.fast_non_dominated_sort-end--->
<!---Documatic-section-fast_non_dominated_sort-end--->

# #
<!---Documatic-section-NSGA II.fast_non_dominated_sort-end--->

<!---Documatic-section-NSGA II.function1-start--->
## NSGA II.function1

<!---Documatic-section-function1-start--->
<!---Documatic-block-NSGA II.function1-start--->
<details>
	<summary><code>NSGA II.function1</code> code snippet</summary>

```python
def function1(x):
    value = -x ** 2
    return value
```
</details>
<!---Documatic-block-NSGA II.function1-end--->
<!---Documatic-section-function1-end--->

# #
<!---Documatic-section-NSGA II.function1-end--->

<!---Documatic-section-NSGA II.function2-start--->
## NSGA II.function2

<!---Documatic-section-function2-start--->
<!---Documatic-block-NSGA II.function2-start--->
<details>
	<summary><code>NSGA II.function2</code> code snippet</summary>

```python
def function2(x):
    value = -(x - 2) ** 2
    return value
```
</details>
<!---Documatic-block-NSGA II.function2-end--->
<!---Documatic-section-function2-end--->

# #
<!---Documatic-section-NSGA II.function2-end--->

<!---Documatic-section-NSGA II.crowding_distance-start--->
## NSGA II.crowding_distance

<!---Documatic-section-crowding_distance-start--->
```mermaid
flowchart LR
NSGA II.crowding_distance-->NSGA II.sort_by_values
NSGA II.sort_by_values-->NSGA II.index_of
```

### Object Calls

* NSGA II.sort_by_values

<!---Documatic-block-NSGA II.crowding_distance-start--->
<details>
	<summary><code>NSGA II.crowding_distance</code> code snippet</summary>

```python
def crowding_distance(values1, values2, front):
    distance = [0 for i in range(0, len(front))]
    sorted1 = sort_by_values(front, values1[:])
    sorted2 = sort_by_values(front, values2[:])
    distance[0] = 4444444444444444
    distance[len(front) - 1] = 4444444444444444
    for k in range(1, len(front) - 1):
        distance[k] = distance[k] + (values1[sorted1[k + 1]] - values2[sorted1[k - 1]]) / (max(values1) - min(values1))
    for k in range(1, len(front) - 1):
        distance[k] = distance[k] + (values1[sorted2[k + 1]] - values2[sorted2[k - 1]]) / (max(values2) - min(values2))
    return distance
```
</details>
<!---Documatic-block-NSGA II.crowding_distance-end--->
<!---Documatic-section-crowding_distance-end--->

# #
<!---Documatic-section-NSGA II.crowding_distance-end--->

<!---Documatic-section-NSGA II.index_of-start--->
## NSGA II.index_of

<!---Documatic-section-index_of-start--->
<!---Documatic-block-NSGA II.index_of-start--->
<details>
	<summary><code>NSGA II.index_of</code> code snippet</summary>

```python
def index_of(a, list):
    for i in range(0, len(list)):
        if list[i] == a:
            return i
    return -1
```
</details>
<!---Documatic-block-NSGA II.index_of-end--->
<!---Documatic-section-index_of-end--->

# #
<!---Documatic-section-NSGA II.index_of-end--->

<!---Documatic-section-NSGA II.crossover-start--->
## NSGA II.crossover

<!---Documatic-section-crossover-start--->
```mermaid
flowchart LR
NSGA II.crossover-->NSGA II.mutation
```

### Object Calls

* NSGA II.mutation

<!---Documatic-block-NSGA II.crossover-start--->
<details>
	<summary><code>NSGA II.crossover</code> code snippet</summary>

```python
def crossover(a, b):
    r = random.random()
    if r > 0.5:
        return mutation((a + b) / 2)
    else:
        return mutation((a - b) / 2)
```
</details>
<!---Documatic-block-NSGA II.crossover-end--->
<!---Documatic-section-crossover-end--->

# #
<!---Documatic-section-NSGA II.crossover-end--->

<!---Documatic-section-NSGA II.sort_by_values-start--->
## NSGA II.sort_by_values

<!---Documatic-section-sort_by_values-start--->
```mermaid
flowchart LR
NSGA II.sort_by_values-->NSGA II.index_of
```

### Object Calls

* NSGA II.index_of

<!---Documatic-block-NSGA II.sort_by_values-start--->
<details>
	<summary><code>NSGA II.sort_by_values</code> code snippet</summary>

```python
def sort_by_values(list1, values):
    sorted_list = []
    while len(sorted_list) != len(list1):
        if index_of(min(values), values) in list1:
            sorted_list.append(index_of(min(values), values))
        values[index_of(min(values), values)] = math.inf
    return sorted_list
```
</details>
<!---Documatic-block-NSGA II.sort_by_values-end--->
<!---Documatic-section-sort_by_values-end--->

# #
<!---Documatic-section-NSGA II.sort_by_values-end--->

<!---Documatic-section-NSGA II.mutation-start--->
## NSGA II.mutation

<!---Documatic-section-mutation-start--->
<!---Documatic-block-NSGA II.mutation-start--->
<details>
	<summary><code>NSGA II.mutation</code> code snippet</summary>

```python
def mutation(solution):
    mutation_prob = random.random()
    if mutation_prob < 1:
        solution = min_x + (max_x - min_x) * random.random()
    return solution
```
</details>
<!---Documatic-block-NSGA II.mutation-end--->
<!---Documatic-section-mutation-end--->

# #
<!---Documatic-section-NSGA II.mutation-end--->

[_Documentation generated by Documatic_](https://www.documatic.com)